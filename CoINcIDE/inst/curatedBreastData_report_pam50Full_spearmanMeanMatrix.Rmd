curatedOvarianData meta-clustering with 200 (meta-rank) features using kmeans consensus
========================================================
**Data loading**


This is a report for the curatedOvarianData meta-clustering. Initial clustering was done using k-means and selecting k via the maximum mean cluster consensus (I found this gave stable results, but I am still exploring 1 other metric.) First, I loaded up my data just past the CoINcIDE" "getAdjMatrices() function (that's the function that takes  a really long time to run and is hogging up server space, as this is the part that computes the edge p-values):

```{r}
#grab data matrix list, clust features list

CoINcIDE_clusterOutput <-  "/home/kplaney/breast_analysis//kmeansConsensuspam50_full_Nstart1pItem9_pam50FullFeatures_2015-04-28.RData.gzip"
load(CoINcIDE_clusterOutput)
clusterOutput <- kmeansConsensuspam50_full_Nstart1pItem9
#data matrix list:
load("/home/kplaney/breast_analysis/curatedBreastData_dataMatrixList_proc_minVar001_min10kGenes_min40Samples.RData.gzip")


source("/home/kplaney/gitRepos/CoINcIDE/coincide/CoINcIDE/R/CoINcIDE_geneExprProcess.R")
source("/home/kplaney/gitRepos/CoINcIDE/coincide/CoINcIDE/R/CoINcIDE_communityDetection.R")
source("/home/kplaney/gitRepos/CoINcIDE/coincide/CoINcIDE/R/CoINcIDE_visualization.R")
#source("/home/kplaney/gitRepos/CoINcIDE/coincide/CoINcIDE/R/CoINcIDE_metaClusterAnalysis.R")


clustSampleIndexList <-  clusterOutput$clustSampleIndexList_PACR
clustFeatureIndexList <- clusterOutput$clustFeatureIndexList_PACR


CoINcIDE_computeEdgesObject <- "/home/kplaney/breast_analysis/adjMatrices_pam50Full_spearman_meanMatrix_2015-04-29.RData.gzip"
load(CoINcIDE_computeEdgesObject)
output <- pam50Full_spearman_meanMatrix
inputVariablesDF <- output$inputVariablesDF
computeTrueSimilOutput <- output$computeTrueSimilOutput
pvalueMatrix <- output$pvalueMatrix
clustIndexMatrix <- output$clustIndexMatrix

###inputs for edge detection
meanEdgePairPvalueThresh <- .01
indEdgePvalueThresh <- .05
minTrueSimilThresh <- .5
maxTrueSimilThresh <- Inf
clustSizeFractThresh <- inputVariablesDF$clustSizeFractThresh
clustSizeThresh <- 5
fractFeatIntersectThresh <- inputVariablesDF$fractFeatIntersectThresh
  numFeatIntersectThresh <- inputVariablesDF$numFeatIntersectThresh
saveDir <- "/home/kplaney/breast_analysis/"
```

**Input variables used to derive adjacency matrix**


```{r}
message("Input variables used to derive the adjacency matrix:\n")
inputVariablesDF
message("There were ",nrow(clustIndexMatrix), " total input clusters from ",length(unique(clustIndexMatrix[,2])), " studies")
message("The total number of input features was ",length(metaFeatures$finalFeatures))
message("Across the entire square (nonsymmetric) p-value matrix, there are ",length(which(pvalueMatrix<=.1))," pvalues less than or equal to .1")
message("Across the entire square (nonsymmetric) p-value matrix, there are ",length(which(pvalueMatrix<=.05))," pvalues less than or equal to .05")
message("Across the entire square (symmetric) similarity matrix, there are ",length(which(computeTrueSimilOutput$similValueMatrix>=inputVariablesDF$minTrueSimilThresh))," similarities greater than or equal to ",inputVariablesDF$minTrueSimilThresh)
```

**Network Analysis**

As we can see in these plots, 4 meta-clusters remained after edge filtering. 
```{r}
finalEdgeInfo <- assignFinalEdges(computeTrueSimilOutput=computeTrueSimilOutput,pvalueMatrix=pvalueMatrix,indEdgePvalueThresh=indEdgePvalueThresh,
                              meanEdgePairPvalueThresh=meanEdgePairPvalueThresh,
                              minTrueSimilThresh=minTrueSimilThresh,maxTrueSimilThresh=maxTrueSimilThresh,
                              fractFeatIntersectThresh=fractFeatIntersectThresh,numFeatIntersectThresh=numFeatIntersectThresh ,
                              clustSizeThresh=clustSizeThresh, clustSizeFractThresh= clustSizeFractThresh,saveDir=saveDir,fileTag="CoINcIDE_edges_",restrictEdges=FALSE
)
#COME BACK: fastgreedy or edgeBetween
commInfo <- findCommunities(edgeMatrix=finalEdgeInfo$filterEdgeOutput$edgeMatrix,edgeWeightMatrix=finalEdgeInfo$filterEdgeOutput$edgeWeightMatrix,
                                        clustIndexMatrix=output$clustIndexMatrix,fileTag="autoReport",
                            saveDir=saveDir,minNumUniqueStudiesPerCommunity=3,clustMethodName="",
                            commMethod=c("fastgreedy"),
                            makePlots=TRUE,saveGraphData=FALSE,plotToScreen=TRUE)
 advancedNetworkPlots(communityMembership=commInfo,
                                  brewPal = c("Set3"),
                                  saveDir=saveDir,saveName="network",
                      plotToScreen=TRUE)$network_stats
```

**Gene meta-rank Analysis**


I ranked genes within each meta-cluster for all samples, and then ran a Kruskal test to see which genes significantly stratified/differentiated patients across the 4 meta-clusters. I still need to implement GSEA; it turns out there's a base GSEA package in Biocondcutor so I've decided to just adapt my code and use their baseline functions.


In the heatmap: red means that gene was ranked high in terms of expression level for patients in that meta-cluster (I took the median rank across all samples in a meta-cluster to create the heatmap. Only significant genes are shown in the heatmap but at over 80 significant genes, of course the gene names are illegible...I print out the top 20 genes below.) The actual meta-cluster numbers are not 1:4 because meta-clusters with only 2 studies were thresholded out earlier.

```{r}
aggregateData <- returnSampleMemberMatrix(clustSampleIndexList,dataMatrixList,communityInfo=commInfo)

load("/home/kplaney/breast_analysis/pam50FullAndShort_subtypeDF.RData.gzip")
#hmmm...pam50 short seems to work better? perhaps because they all share the same genes?
#careful: any duplicated sample names (across different studies)
any(duplicated(subtypeDF_master$sampleName))
any(duplicated(aggregateData$sampleClustCommKey$sampleName))
subtypeDF <- subtypeDF_master[na.omit(match(aggregateData$sampleClustCommKey$sampleName,
                                                                         subtypeDF_master$sampleName)), ]

all(subtypeDF$sampleName==aggregateData$sampleClustCommKey$sampleName)
aggregateData$sampleClustCommKey$subtype <- subtypeDF$subtype


table(aggregateData$sampleClustCommKey$subtype,aggregateData$sampleClustCommKey$community)
#very few HER2 samples...

binInfo <- binarizeMetaclustStudyStatus(aggregateData$sampleClustCommKey)
rankInfo <- computeRankMatrix(metaClustSampleNames=binInfo$metaClustSampleNames,
                              featureNames=metaFeatures$finalFeatures,dataMatrixList,
                              sampleClustCommKey=aggregateData$sampleClustCommKey,onlyIntersectingFeat=TRUE)
pvalueInfo <- computeFeaturePvalues(rankMatrix=rankInfo$rankMatrix,featureNames=rankInfo$filteredFeatures,groupings=rankInfo$groupings)
message("There are ",length(which(pvalueInfo$fdr.qvalue<=.05)), " genes with an FDR corrected p-value below .05 whose ranks significantly differed among all of the meta-clusters (using Kruskal's test)")
message("Top 20 significant genes:\n")
rownames(pvalueInfo[which(pvalueInfo$fdr.qvalue<=.05)[1:20],])
cat("\n")

metaMatrix <- commMedianRank(rankInfo$rankMatrix[which(pvalueInfo$fdr.qvalue<=.05),],rankInfo$groupings)
message("Red in heatmap means genes were ranked higher across all samples in that meta-cluster.")
plotMetaAnalysis(metaMatrix,saveFile=FALSE,plotToScreen=TRUE,
                             saveDir=saveDir,fileTag="test",
                             plotTitle="Median rank\nacross all samples/studies",
                             key.xlab="")

#save variable
sampleClustCommKey<-aggregateData$sampleClustCommKey
```

**GSEA Analysis**

It turns out "GSEABase" isn't all that great..so just using some Broad gene sets I already downloaded and the standard hypergeometric tests:

```{r}
GSEA_out <- GSEA(testGeneVector=rownames(metaMatrix),method=c("hypergeometric","fisher"),genomeSize=20000,
                  refGeneListDir="/home/data/MSigDB/GSEA_base_MSigDB_lists_merged.RData.gzip")

message("Gene lists enriched with q-value below .05:")
load("/home/data/MSigDB/GSEA_base_MSigDB_lists_merged.RData.gzip")
names(GSEA_base_MSigDB_lists_merged)[which(GSEA_out$qvalues<=.05)]
```
**Survival Analyses**
I'm still working on determing which long-term and binary variables have the least amount of NAs across the samples in these meta-clusters, but it does look like the binary vital_status variable (alive or dead) and continous days to death variables provide survival curves that significantly stratify patients. It was less significant when I used a 5-year cutoff.

 ```{r}
library("survival")
#already have esets loaded:
 #load("/home/kplaney/ovarian_analysis/esets_proc_TCGAcombat.RData.gzip")
phenoMasterDF <- createPhenoMasterTableFromMatrixList(esetList=esets)
#save(phenoMasterDF,file="/home/kplaney/ovarian_analysis/curatedOvarian_phenoMasterDF.RData.gzip",compress="gzip")
#load("/home/kplaney/ovarian_analysis/curatedOvarian_phenoMasterDF.RData.gzip")
#study numbers won't align here because some filtered out (had no robust clusters); need to "translate"

origToNewIndexMap <- data.frame(origToNewIndexMap,stringsAsFactors=FALSE)
colnames(origToNewIndexMap) <- c("studyNum","origStudyNum")
sampleClustCommKey <- join(sampleClustCommKey,origToNewIndexMap,by="studyNum",type="full",match="all")
sampleClustCommPhenoData <- addClinicalVarToNodeAttributes(sampleClustCommKey,phenoMasterDF=phenoMasterDF)

#survival analysis
outcomesVarBinary="vital_status"
outcomesVarCont = "days_to_death"
CutoffPointYears=5
uniquePatientID="unique_patient_ID"
groupingTerm="community"
   
     
  #only take samples with the groupingTerm you're looking at.
  sampleClustCommPhenoData <- sampleClustCommPhenoData[which(!is.na(sampleClustCommPhenoData[, groupingTerm])), ]
  #remove samples with NA values.
  groupings <- sampleClustCommPhenoData[, groupingTerm]
  
  #groupings <- groupings[which(!is.na(sampleClustCommPhenoData[,outcomesVarBinary]))];
  #outcomesData <- sampleClustCommPhenoData[which(!is.na(sampleClustCommPhenoData[,outcomesVarBinary])),];
  
  #keep samples with NA days to event for now?
#hmm...one meta-cluster is left out if use "days_to_death"...
  #groupings <- as.numeric(as.factor(groupings[which(!is.na(outcomesData[,outcomesVarCont]))]))
  #outcomesData <- outcomesData[which(!is.na(outcomesData[,outcomesVarCont])),];
  
  #if binary is character string categories: make it a factor first, then numeric,
  #otherwise coxph function will throw errors.
#  nonCensoredTerm=1
sampleClustCommPhenoData[which(sampleClustCommPhenoData[ ,outcomesVarBinary]=="deceased"),outcomesVarBinary] <- 1
sampleClustCommPhenoData[which(sampleClustCommPhenoData[ ,outcomesVarBinary]=="living"),outcomesVarBinary] <- 0
  outcomesDataShort <- data.frame(as.numeric(sampleClustCommPhenoData[,outcomesVarBinary]),as.numeric(sampleClustCommPhenoData[,outcomesVarCont])
  );
  
  #sometimes the names are duplicated across studies - remove this line
  #rownames(outcomesDataShort ) <- outcomesData[,uniquePatientID];
  colnames(outcomesDataShort) <- c("Censoring","TimeToLastContactOrEvent")
  
  nonCensoredTerm=1
  censoredTerm=0
  Survival <- outcomesDataShort
  #creating the survival objects with the time and censoring variables
  OverallSurvival <- Surv(Survival$TimeToLastContactOrEvent,Survival$Censoring==nonCensoredTerm);
  #creating a survival object cutoff at a certain point
   CutoffPoint <- CutoffPointYears*365;
   CutoffSamples=Survival$TimeToLastContactOrEvent>CutoffPoint & !is.na(Survival$TimeToLastContactOrEvent)
   SurvivalCutoff=Survival
   SurvivalCutoff$TimeToLastContactOrEvent[CutoffSamples]=CutoffPoint
   SurvivalCutoff$Censoring[CutoffSamples]=censoredTerm
#   #"Surv" creates a survival object. really for binary outcomes data.
   OverallSurvivalCutoff=Surv(SurvivalCutoff$TimeToLastContactOrEvent,SurvivalCutoff$Censoring==nonCensoredTerm)

    coxfit=coxph(OverallSurvival~groupings, data=Survival)
  message("coxfit summary for overall survival.")
  summary(coxfit)
  #plot(cox.zph(coxfit))
 kmfit=survdiff(OverallSurvival ~ groupings)
message("kaplan meier p-value for overall survival:")
 1 - pchisq(kmfit$chisq, length(kmfit$n) - 1)

message("calculating the sign of the survival relationship")
  mfit=survfit(OverallSurvival ~ groupings)
  plot(mfit,main="overall survival")
  
  coxfit=coxph(OverallSurvivalCutoff~groupings, data= SurvivalCutoff)
  message("coxfit summary for survival cutoff at ",CutoffPointYears,"years:")
  summary(coxfit)
 #plot(cox.zph(coxfit))
  
  kmfit=survdiff(OverallSurvivalCutoff ~ groupings)
message("kaplan meier p-value for survival cutoff:")
  1 - pchisq(kmfit$chisq, length(kmfit$n) - 1)  


message("a chi-square test looking at the binary recurrence status variable, as this data was recorded at least in some patients in all 4 meta-clusters:")

chisq.test(sampleClustCommPhenoData[,"recurrence_status"],groupings)
message("We see a trend by just tabling the recurrence status variable too, but it's still pretty 50-50 (for the samples that didn't have NA values; it looks like a lot of samples were still missing this variable from certain meta-clusters")
table(sampleClustCommPhenoData[,"recurrence_status"],groupings)
 
 ```
